---
typora-copy-images-to: ./
typora-root-url: 图片
---

## JDBC（java database connection）

持久化：将数据保存到可掉电的存储设备中。

数据持久化意味着把内存中的数据保存到硬盘中

![536027248915](C:\Users\pinkill\Desktop\大数据typora/1536027248915.png)

![1536027439795](C:\Users\pinkill\Desktop\大数据typora\图片\1536027439795.png)

#### 1.DriverManager

DriverManager是驱动管理类

- 可以通过重载的getConnection()方法获取数据库连接对象；可以同时管理多个驱动类。
- 可以同时管理多个驱动程序：如注册了多个数据库连接，则调用getConnection()方法时传入参数不同，返回不同数据库连击。

注册驱动

 class.forName();

com.mysql.jdbc.Driver通过静态代码块加载了Driver，不再次加载驱动。

获取连接对象

| return | 方法 |
| :------------------ | ------------------------------------------------------------ |
|      `static Connection`                |                                                   `getConnection(String url, String user, String password)`             试图建立到给定数据库 URL 的连接。           |

url-->jdbc:mysql://localhost:3306/test1

- jdbc:连接数据库协议
- mysql：jdbc子协议
- 后面是ip：port/数据库

```java
Class.forName("com.mysql.jdbc.Driver");
		
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test1", "root", "1234");
```



#### 2.Connection

##### 2.1创建执行sql语句的对象

| return | 方法 |
| ------------ | ------------------------------------------------------------ |
| ` Statement` | `createStatement()`             创建一个 `Statement` 对象来将 SQL 语句发送到数据库。 |
| ` PreparedStatement` | `prepareStatement(String sql,  int autoGeneratedKeys)`            创建一个默认  `PreparedStatement` 对象，该对象能获取自动生成的键 |
| ` CallableStatement` | `prepareCall(String sql)`             创建一个 `CallableStatement` 对象来调用数据库存储过程。 |
| ` void`              | `rollback()`             取消在当前事务中进行的所有更改，并释放此 `Connection`  对象当前持有的所有数据库锁。 |


##### 2.2管理事务

包括升级与回滚

| return | 方法 |
| ---- | ---- |
| `void`               | `rollback(Savepoint savepoint)`             取消所有设置给定 `Savepoint` 对象之后进行的更改。 |
| ` Savepoint`         | `setSavepoint()`             在当前事务中创建一个未命名的保存点 (savepoint)，并返回表示它的新 `Savepoint` 对象。 |
| `Savepoint`          | `setSavepoint(String name)`             在当前事务中创建一个具有给定名称的保存点，并返回表示它的新 `Savepoint` 对象。 |
| `void`               | `commit()`             使所有上一次提交/回滚后进行的更改成为持久更改，并释放此 `Connection`  对象当前持有的所有数据库锁。 |

#### 3.Statement

sql执行对象

##### 3.1 执行sql

| return       | 方法                                                         |
| ------------ | ------------------------------------------------------------ |
| ` boolean`   | `**execute**(String sql)`             执行给定的 SQL 语句，该语句可能返回多个结果。 |
| ` ResultSet` | `**executeQuery**(String sql)`             执行给定的 SQL 语句，该语句返回单个 `ResultSet` 对象。 |
| ` int`       | `**executeUpdate**(String sql)`             执行给定 SQL 语句，该语句可能为 `INSERT`、`UPDATE` 或  `DELETE` 语句，或者不返回任何内容的 SQL 语句（如 SQL DDL 语句）。 |

##### 3.2批处理

| return   | 方法                                                         |
| -------- | ------------------------------------------------------------ |
| ` int[]` | `**executeBatch**()`             将一批命令提交给数据库来执行，如果全部命令执行成功，则返回更新计数组成的数组。 |
| ` void`  | `**clearBatch**()`             清空此 `Statement` 对象的当前 SQL 命令列表。 |



##### 4.ResultSet

结果集数据表

| return     | 方法                                                         |
| ---------- | ------------------------------------------------------------ |
| `boolean`  | `next()`             将光标从当前位置向前移一行。            |
| ` boolean` | `previous()`             将光标移动到此 `ResultSet` 对象的上一行。 |
| Xxxxx      | `getXxxxx(int columnIndex)`             以 Java 编程语言中 `Xxxxx` 的形式获取此 `ResultSet`  对象的当前行中指定列的值。 |
| Xxxxx      | `getXxxxx(String columnLabel)`             以 Java 编程语言中 Xxxxx 的形式获取此 `ResultSet`  对象的当前行中指定列的值。 |

第一次在第一行结果之前，没有数据返回false，有数据返回true并下移一行。

![1536030451466](C:\Users\pinkill\Desktop\大数据typora\图片\1536030451466.png)

获取结果集的数据使用getXxxx(String xxx)方法一般不用int类型的列号。当然也可以用getObject()



##### 5.JDBC流程

需要释放reultset,statement,connection需要close();

```java
public void testGetConnection() throw Exception{
    //0.读取jdbc.properties
    /**
     * 可以使用类加载器bin目录下的文件
     */
    Properties pro = new Porperties();
    InputStream inStream = this.getClass()
        .getClassLoader().getResourceAdStream("jdbc.properties");
    pro.load(inStream);
    
    //1.准备字符串url,user,password,driveclass
    String url = "jdbc:mysql://localhost:3306/db_test";
    String user = "root";
    String password = "1234";
    String driveclass = "com.mysql.jdbc.Driver";
    
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    try{
        //2.加载驱动：Class.forName(driveclass)
        Class.forName(driveclass);

        //3.获取数据库连接
        //DirverManager.getConnection(url,user,password)
        conn = DirverManager.getConnection(url,user,password);

        //4.获取sql的执行对象
        stmt = conn.createStatement();

        //5.准备sql执行，query操作结果集/update判断执行成功
        String sql = "select * from t_test";
        rSet = stmt.executeQuery(sql);

        while (rSet.next()) {
            System.out.println(rSet.getString("cname"));
        }
    }catch(SQLException e){
        e.printExceptionTrace();
    }finally{
    //6.关闭资源，先创建后关闭
        if(rs != null){
            try{
                rs.close();
             } catch(SQLException e){
        		e.printExceptionTrace();
    		}
            rs = null;//方便JVM GC
        }
        if(stmt != null){
            try{
                stmt.close();
             } catch(SQLException e){
        		e.printExceptionTrace();
    		}
            stmt = null;
        }
        if(conn != null){
            try{
                conn.close();
             } catch(SQLException e){
        		e.printExceptionTrace();
    		}
            conn = null;
        }
    }
}
```





##### 6.PrepareStatement

PrepareStatement是 Statement的一个子接口，可以传入带占位符的语句

1. **使用statment需要拼SQL，而且容易出错**

2. **希望String sql = "insert into t_test values(?,?,?,?)";**

	 		prep.setXxx(int index,Xxxx xxx);
     index从1开始

3. **有效的禁止sql**

	 	利用系统没有对用户输入进行充分的检查，在用户输入数据中注入非法的sql语句或者命令，
    从而利用系统的sql引擎完成恶意行为的做法。
     	使用PrepareStatement可以有效避免



4. **可读性与可维护**

	 		语法检查，语义检查，翻译成二进制命令，缓存

5. **性能优化**

###### sql注入漏洞

```java
public void testSQLInjection() {
		String username = "a' or pass = ";
		String password = " or '1=1";
		String sql = "select * from users where username = '"+username+"' and password = '"+password+"'";
	
		/*
		 * 只需要想办法然让where后面为true就好了
		 * 		select * from users where username = '' and password = '';
		 * 那么现在进行如下构造,
		 * 	通过a后面的单引号将第一个条件完成将第二个条件的key变为随意给定key的值
		 * 	通过后面的or以及单引号引入一个恒定为true的条件完成
		 * 		select * from users where username = 'a' or pass = ' and password = ' or '1=1';
		 */
```









#### 通过反射与元数据来完成通用的查询

![1536043440382](C:\Users\pinkill\Desktop\大数据typora\图片\1536043440382.png)

![1536046210259](C:\Users\pinkill\Desktop\大数据typora\图片\1536046210259.png)

sql：要注意将字段的别名与javabean的成员变量属性名对应，这样就可以赋值了

##### ResultSetMetaData

```java
Map<String, Object> values =  new HashMap<String, Object>();

//1.得到ResultSetMetaData对象
ResultSetMetaData rsmd = resultSet.getMetaData();

//2.获取列的别名
while(rs.next()){
    for(int i = 0;i<rsmd.getColumnCount();i++){
        String columnLabel = rsmd.getColumnLabel(i+1);//通过该方法获得
        Object columnValue = rs.getObject(columnLabel);
		
        values.put(columnLabel,value);
    }
    Class clazz = Student.Class;
    Object object = clazz.newInstance();
    for(Map.Entry<String,Object> entry : values.entrySet()){
        String fieldName = entry.getKey();
        Object fieldValues = entry.getValue();
        
        /*
         * 通过反射赋值，见本文最后的工具类方法
         */
        ReflectionUtils.setFieldValue(object,fieldName,fieldValues);
    }
}
```



#### JDBC DAO设计模式

DAO ：database access object

作用：访问数据信息的类，包含了对数据的CRUD(create , read ,update ,delete)

原因：实现功能的模块，更有利于代码的维护升级

```java
public void update(String sql, Object...object) {

}

public <T> T get(Class<T> clazz,String sql,Object...args) {

    return null;
}

public <T> List<T> getForList(Class<T> clazz,String sql,Object ... args){

    return null;
}

public <E> E getForValue(String sql,Object ... args) {

    return null;
}
```

获取数据库数据并转换为bean实例

```java
public <T> List<T> getForList(Class<T> clazz,String sql,Object ... args){
	//定义资源对象	
    List<T> entityList = new ArrayList<>();
    T entity = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet rs = null;
    try {
        //获取连接对象
        connection = JDBCUtils.getConnection();
        //获取sql的执行对象
        preparedStatement = connection.prepareStatement(sql);
        //为PreparedStatment设置值
        for (int i = 0; i < args.length; i++) {
            preparedStatement.setObject(i+1, args[i]);
        }
        //获取ResultSet
        rs = preparedStatement.executeQuery();
        
        while (rs.next()) {
            //获取ResultSetMetaData
            ResultSetMetaData rsmd = rs.getMetaData();
            int columncount = rsmd.getColumnCount();
            entity = clazz.newInstance();
            //通过元数据获取列label和列对应值，
            for (int i = 0; i < columncount; i++) {
                String columnLable = rsmd.getColumnLabel(i+1);
                Object columnValue = rs.getObject(columnLable);
                //每组key-value设置一个属性
                BeanUtils.setProperty(entity, columnLable, columnValue);
            }
            //添加到list中
            entityList.add(entity);
        }

    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        //释放资源
        JDBCUtils.clearResource(connection, preparedStatement, rs);
    }
    return entityList;
}
```



#### 元数据

DatabaseMetaData

- Connection获取
```java
DatabaseMetaData database = connection.getMetaData();
String name = database.getUserName();
ResultSet rs = data.getCatalogs();

```

ParameterMetaData

```java
connection = JDBCUtils.getConnection();
preparedStatement = connection.prepareStatement(sql);
ParameterMetaData PMD = preparedStatement.getParameterMetaData();
for (int i = 0; i < PMD.getParameterCount(); i++) {
    preparedStatement.setObject(i + 1, args[i]);
}
preparedStatement.executeUpdate();
```

ResultSetMetaData

`rsmd.getColumnLabel(i+1);`会得到执行结果表的lable字段，如别名

```java
rs = preparedStatement.executeQuery();
while (rs.next()) {
    ResultSetMetaData rsmd = rs.getMetaData();
    int columncount = rsmd.getColumnCount();
    entity = clazz.newInstance();
    for (int i = 0; i < columncount; i++) {
        String columnLable = rsmd.getColumnLabel(i+1);
        Object columnValue = rs.getObject(columnLable);
        BeanUtils.setProperty(entity, columnLable, columnValue);
    }
    entityList.add(entity);
}
```





#### 获取自动生产主键

```java
preparedStatement.getGeneratedKeys();
```



#### JDBC处理事务

connection的方法

|              | `                                                            |
| ------------ | ------------------------------------------------------------ |
| ` void`      | `**setTransactionIsolation**(int level)`             试图将此 `Connection` 对象的事务隔离级别更改为给定的级别。 |
| ` Savepoint` | `**setSavepoint**()`             在当前事务中创建一个未命名的保存点 (savepoint)，并返回表示它的新 `Savepoint` 对象。 |
| ` void`      | `**setAutoCommit**(boolean autoCommit)`             将此连接的自动提交模式设置为给定状态。 |
| ` void`      | `**rollback**()`             取消在当前事务中进行的所有更改，并释放此 `Connection` 对象当前持有的所有数据库锁。 |
| ` void`      | `**rollback**(Savepoint savepoint)`             取消所有设置给定 `Savepoint` 对象之后进行的更改。 |
| ` void`      | `**commit**()`             使所有上一次提交/回滚后进行的更改成为持久更改，并释放此 `Connection`  对象当前持有的所有数据库锁。 |

```java
//不可保证原子性
public void testTransaction(){
    DAO dao = new DAO();
    String sql = "update users set balance = balance-500 where id=1";
    dao.update(sql);
    sql="update users set balance = balance+500 where id=1";
    dao.update(sql);
}

/*
 * 1.开启事务：connection.setAutoCommit(false);
 * 2.执行完sql提交事务：connection.commit();
 * 3.执行异常在catch中回滚：connection.rollback();
 */
public void testTransaction(){
    Connection connection = null;
    try {
        connection = JDBCUtils.getConnection();

        connection.setAutoCommit(false);

        String sql = "update users set balance = balance-500 where id=1";
        update(connection,sql);
        sql="update users set balance = balance+500 where id=1";
        update(connection,sql);
        connection.commit();
    } catch (Exception e) {
        e.printStackTrace();
        try {
            connection.rollback();
        } catch (SQLException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
    }finally {
        JDBCUtils.clearResource(connection, null, null);
    }
}
```



#### 批量处理

| return  | method                                                       |
| ------- | ------------------------------------------------------------ |
| ` void` | `addBatch()`             将一组参数添加到此 `PreparedStatement` 对象的批处理命令中。 |
| int[]   | `executeBatch()`          throws SQLException 将一批命令提交到数据库以执行，并且所有命令都执行成功，返回一个更新计数的数组。  返回的数组的`int`元素被排序以对应于批次中的命令，这些命令根据它们添加到批处理的顺序进行排序。      **inherited from interface java.sql.[Statement]** |



#### 调用存储过程与函数

CallabelStatement

###### what

- The interface used to execute SQL stored procedures.

```sql
{?= call <procedure-name>[(<arg1>,<arg2>, ...)]}
{call <procedure-name>[(<arg1>,<arg2>, ...)]}
```

相关方法

| return | method                                                       |
| ------ | ------------------------------------------------------------ |
| void   | `registerOutParameter(int parameterIndex,  int sqlType)`  Registers the OUT parameter in ordinal position  `parameterIndex` to the JDBC type `sqlType`.                                    `registerOutParameter(String parameterName, int sqlType)`   Registers the OUT parameter named `parameterName` to  the JDBC type `sqlType`. |
| void   | `setXxxx(String parameterName, Xxxx x)`  Sets the designated parameter to the given Java  `Xxxx` value. |
| Xxxx   | `getXxxx(Xxxx parameterName)`  Retrieves the value of a JDBC `CHAR`,  `VARCHAR`, or `LONGVARCHAR` parameter as a  `Xxxx` in the Java programming language. |



工具类：

```java
package DAO;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

/**
 * 反射的 Utils 函数集合
 * 提供访问私有变量, 获取泛型类型 Class, 提取集合中元素属性等 Utils 函数
 * @author Administrator
 *
 */
public class ReflectionUtils {

	
	/**
	 * 通过反射, 获得定义 Class 时声明的父类的泛型参数的类型
	 * 如: public EmployeeDao extends BaseDao<Employee, String>
	 * @param clazz
	 * @param index
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static Class getSuperClassGenricType(Class clazz, int index){
		Type genType = clazz.getGenericSuperclass();
		
		if(!(genType instanceof ParameterizedType)){
			return Object.class;
		}
		
		Type [] params = ((ParameterizedType)genType).getActualTypeArguments();
		
		if(index >= params.length || index < 0){
			return Object.class;
		}
		
		if(!(params[index] instanceof Class)){
			return Object.class;
		}
		
		return (Class) params[index];
	}
	
	/**
	 * 通过反射, 获得 Class 定义中声明的父类的泛型参数类型
	 * 如: public EmployeeDao extends BaseDao<Employee, String>
	 * @param <T>
	 * @param clazz
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public static<T> Class<T> getSuperGenericType(Class clazz){
		return getSuperClassGenricType(clazz, 0);
	}
	
	/**
	 * 循环向上转型, 获取对象的 DeclaredMethod
	 * @param object
	 * @param methodName
	 * @param parameterTypes
	 * @return
	 */
	public static Method getDeclaredMethod(Object object, String methodName, Class<?>[] parameterTypes){
		
		for(Class<?> superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()){
			try {
				//superClass.getMethod(methodName, parameterTypes);
				return superClass.getDeclaredMethod(methodName, parameterTypes);
			} catch (NoSuchMethodException e) {
				//Method 不在当前类定义, 继续向上转型
			}
			//..
		}
		
		return null;
	}
	
	/**
	 * 使 filed 变为可访问
	 * @param field
	 */
	public static void makeAccessible(Field field){
		if(!Modifier.isPublic(field.getModifiers())){
			field.setAccessible(true);
		}
	}
	
	/**
	 * 循环向上转型, 获取对象的 DeclaredField
	 * @param object
	 * @param filedName
	 * @return
	 */
	public static Field getDeclaredField(Object object, String filedName){
		
		for(Class<?> superClass = object.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()){
			try {
				return superClass.getDeclaredField(filedName);
			} catch (NoSuchFieldException e) {
				//Field 不在当前类定义, 继续向上转型
			}
		}
		return null;
	}
	
	/**
	 * 直接调用对象方法, 而忽略修饰符(private, protected)
	 * @param object
	 * @param methodName
	 * @param parameterTypes
	 * @param parameters
	 * @return
	 * @throws InvocationTargetException 
	 * @throws IllegalArgumentException 
	 */
	public static Object invokeMethod(Object object, String methodName, Class<?> [] parameterTypes,
			Object [] parameters) throws InvocationTargetException{
		
		Method method = getDeclaredMethod(object, methodName, parameterTypes);
		
		if(method == null){
			throw new IllegalArgumentException("Could not find method [" + methodName + "] on target [" + object + "]");
		}
		
		method.setAccessible(true);
		
		try {
			return method.invoke(object, parameters);
		} catch(IllegalAccessException e) {
			System.out.println("不可能抛出的异常");
		} 
		
		return null;
	}
	
	/**
	 * 直接设置对象属性值, 忽略 private/protected 修饰符, 也不经过 setter
	 * @param object
	 * @param fieldName
	 * @param value
	 */
	public static void setFieldValue(Object object, String fieldName, Object value){
		//不在当前就在其父类
		Field field = getDeclaredField(object, fieldName);
		
		if (field == null)
			throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
		
		makeAccessible(field);
		
		try {
			field.set(object, value);
		} catch (IllegalAccessException e) {
			System.out.println("不可能抛出的异常");
		}
	}
	
	/**
	 * 直接读取对象的属性值, 忽略 private/protected 修饰符, 也不经过 getter
	 * @param object
	 * @param fieldName
	 * @return
	 */
	public static Object getFieldValue(Object object, String fieldName){
		Field field = getDeclaredField(object, fieldName);
		
		if (field == null)
			throw new IllegalArgumentException("Could not find field [" + fieldName + "] on target [" + object + "]");
		
		makeAccessible(field);
		
		Object result = null;
		
		try {
			result = field.get(object);
		} catch (IllegalAccessException e) {
			System.out.println("不可能抛出的异常");
		}
		
		return result;
	}
}

```

