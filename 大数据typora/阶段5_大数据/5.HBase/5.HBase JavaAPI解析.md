### 5.1 引入POM

```xml
<dependency>
    <groupId>org.apache.hbase</groupId>
    <artifactId>hbase-server</artifactId>
    <version>${hbase.version}</version>
</dependency>
<dependency>
    <groupId>org.apache.hbase</groupId>
    <artifactId>hbase-client</artifactId>
    <version>${hbase.version}</version>
</dependency>
```

### 5.2 拷贝配置文件hbase-site.xml

在编写MR时这个配置文件会加到默认配置中，形成HBase使用的**`Configuration`**,名字必须为`hbase-default.xml`或者`hbase-site.xml`

```xml
<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="configuration.xsl"?>
<configuration>
    <property>
        <name>hbase.rootdir</name>
        <value>hdfs://hadoop102:9000/hbase</value>
    </property>
    <property>
        <name>hbase.cluster.distributed</name>
        <value>true</value>
    </property>
    <!-- 0.98 后的新变动，之前版本没有.port,默认端口为 60000 -->
    <property>
        <name>hbase.master.port</name>
        <value>16000</value>
    </property>
    <!-- zk集群 -->
    <property>
        <name>hbase.zookeeper.quorum</name>
        <value>hadoop102:2181,hadoop103:2181,hadoop104:2181</value>
    </property>
    <!-- zk数据目录，如果不是默认的话 -->
    <property>
        <name>hbase.zookeeper.property.dataDir</name>
        <value>/opt/module/zookeeper-3.4.10/zkData</value>
    </property>
</configuration>
```

HBase源码如下:

**`HBaseConfiguration`**

```java
 public static Configuration create() {
    Configuration conf = new Configuration();
    // In case HBaseConfiguration is loaded from a different classloader than
    // Configuration, conf needs to be set with appropriate class loader to resolve
    // HBase resources.
    conf.setClassLoader(HBaseConfiguration.class.getClassLoader());
    return addHbaseResources(conf);
  }


  public static Configuration addHbaseResources(Configuration conf) {
    conf.addResource("hbase-default.xml");
    conf.addResource("hbase-site.xml");

    checkDefaultsVersion(conf);
    HeapMemorySizeUtil.checkForClusterFreeMemoryLimit(conf);
    return conf;
  }
```



### 5.3 Java API

#### 5.3.1 获取 Configuration 

各种对象都要从Configuration起步

```java
    public static Configuration conf;

    static {
        conf = HBaseConfiguration.create();
    }
```

#### 5.3.2 判断表存在

连接对象由工厂创建

Admin对象用来执行DDL

```java
	// 判断表是否存在
    public static boolean isExist(String tableName) throws IOException {
		//HBaseAdmin admin = new HBaseAdmin(conf);
        Connection connection = ConnectionFactory.createConnection(conf);
        Admin admin = connection.getAdmin();

        return admin.tableExists(TableName.valueOf(tableName));
    }
```

#### 5.3.3 创建表

创建表需要**`HTableDescriptor`**，需要传入表名

**`TableName.valueOf(String tableName)`**返回TableName对象

**`htd.addFamily`**添加列簇，列簇对象**`HColumnDescriptor`**创建时要传入列簇名

```java
public static void createTable(String tableName, String... columnFamily) throws IOException {
    Connection connection = ConnectionFactory.createConnection(conf);
    Admin admin = connection.getAdmin();

    if (isExist(tableName)) {
        System.out.println("表已存在");
        return;
    }

    HTableDescriptor htd = new HTableDescriptor(TableName.valueOf(tableName));
    for (String cf : columnFamily) {
        (new HColumnDescriptor(cf));
    }
    admin.createTable(htd);
    System.out.println("表创建成功");
}
```

#### 5.3.4 删除表

**`admin`**首先要**`disableTable`**禁用然后在**`deleteTable`**删除

```java
public static void deleteTable(String tableName) throws IOException {
    Connection connection = ConnectionFactory.createConnection(conf);
    Admin admin = connection.getAdmin();

    if (!isExist(tableName)) {
        System.out.println("表不存在！");
        return;
    }
    if (!admin.isTableDisabled(TableName.valueOf(tableName))) {
        admin.disableTable(TableName.valueOf(tableName));
    }
    admin.deleteTable(TableName.valueOf(tableName));
    System.out.println("表删除成功！");
}
```

#### 5.3.5 添加列数据

对于**`DML`**需要Table对象来完成

**`connection.getTable(TableName tableName)`**或者Table对象

添加需要**`Put`**对象，查询需要**`Query`**对象，删除需要**`Delete`**对象

表Table创建需要tableName

Put添加列值需要columnFamily，columnQualifier和value

```java
public Put addColumn(byte [] family, byte [] qualifier, byte [] value)
```
最后用table.put(Put put完成)
```java
public static void addRow(String tableName, String rowKey, String cf, String column, String value) throws IOException {
    Connection connection = ConnectionFactory.createConnection(conf);
    Table table = connection.getTable(TableName.valueOf(tableName));
    Put put = new Put(Bytes.toBytes(rowKey));
    put.addColumn(Bytes.toBytes(cf), Bytes.toBytes(column), Bytes.toBytes(value));
    table.put(put);
}
```

#### 5.3.6 删除行/列数据

和5.3.5相似，使用**`Delete`**对象

```java
//删除行
public Delete(byte [] row)
//删除列
public Delete addColumn(final byte [] family, final byte [] qualifier)
```

```java
public static void deleteRow(String tableName, String rowKey) throws IOException {
    Connection connection = ConnectionFactory.createConnection(conf);
    Table table = connection.getTable(TableName.valueOf(tableName));
    Delete delete = new Delete(Bytes.toBytes(rowKey));
    table.delete(delete);
}
```

多行循环添加到**`Delete[]`**然后用table删除

#### 5.3.7 获取数据

获取数据由**`table.get(Get get)`**来的得到

**`new Get(byte [] rowKey)`**



对于全表扫描或是条件扫描需要由**`Scan`**来获取

table.getScanner(scan)返回**`ResultScanner`**，对于**`ResultScanner extends Iterable<Result>`**所以是可以迭代的

**`Cell[] cells = result.rawCells()`**获取到cell对象，

1. **`byte[] CellUtil.cloneRow(cell)`**获取到RowKey，需要用 Bytes.toString(byte[] bytes）转换
2. **`byte[] CellUtil.cloneFamily(cell)`**获取ColumnFamily
3. **`byte[] CellUtil.cloneQualifier(cell)`**获取Column
4. **`byte[] CellUtil.cloneValue(cell)`**获取Column的value

```java
public static void getRow(String tableName, String rowKey) throws IOException {
    Connection connection = ConnectionFactory.createConnection(conf);
    Table table = connection.getTable(TableName.valueOf(tableName));
    Get get = new Get(Bytes.toBytes(rowKey));

    Result result = table.get(get);

    Cell[] cells = result.rawCells();
    for (Cell cell : cells) {
        System.out.println("行键：" + Bytes.toString(CellUtil.cloneRow(cell)));
        System.out.println("列族：" + Bytes.toString(CellUtil.cloneFamily(cell)));
        System.out.println("列：" + Bytes.toString(CellUtil.cloneQualifier(cell)));
        System.out.println("值：" + Bytes.toString(CellUtil.cloneValue(cell)));
    }

}

public static void getAllRows(String tableName) throws IOException {
    Connection connection = ConnectionFactory.createConnection(conf);
    Table table = connection.getTable(TableName.valueOf(tableName));
    Scan scan = new Scan();
    //        scan.setMaxVersions();

    ResultScanner resultScanner = table.getScanner(scan);
    for (Result result : resultScanner) {
        Cell[] cells = result.rawCells();
        for (Cell cell : cells) {
            System.out.println("行键：" + Bytes.toString(CellUtil.cloneRow(cell)));
            System.out.println("列族：" + Bytes.toString(CellUtil.cloneFamily(cell)));
            System.out.println("列：" + Bytes.toString(CellUtil.cloneQualifier(cell)));
            System.out.println("值：" + Bytes.toString(CellUtil.cloneValue(cell)));
        }
    }
}
```

