# SpringBoot自动配置原理

SpringBoot从主方法启动后会加载配置类，那么是怎么生效的？

```java
@SpringBootApplication

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
```

`@SpringBootApplication`注解是上文中所列举的所有注解的总和，最主要的是后面3个。

## 1.SpringBoot启动

SpringBoot启动的时候加载了主配置类，自动配置由`@EnableAutoConfiguration`开启。

### 1.1 @EnableAutoConfiguration解析

**@EnableAutoConfiguration如其名，开启自动配置功能，它又是如何开启的呢？**

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
```

这里`@Import(AutoConfigurationImportSelector.class)`导入了一个类

> ```
> {@link DeferredImportSelector} to handle {@link EnableAutoConfiguration
> auto-configuration}. 
> This class can also be subclassed if a custom variant of
> {@link EnableAutoConfiguration @EnableAutoConfiguration} is needed.
> ```

AutoConfigurationImportSelector实现了DeferredImportSelector间接实现了ImportSelector

而ImportSelector是为了导入配置类中所给定的类。

> ```
> Interface to be implemented by types that determine which @{@link Configuration}
> class(es) should be imported based on a given selection criteria, usually one or
> more annotation attributes.
> ```

### 1.2 AutoConfigurationImportSelector解析

**AutoConfigurationImportSelector导入了那些类呢？**回到实现中来看

```java
@Override
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    }
    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
        .loadMetadata(this.beanClassLoader);
    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);
    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
}
```

这个方法返回的是一个字符串列表，其内容由**autoConfigurationEntry.getConfigurations()**得来，那么这个工厂实例到底到底得到了什么？其实很简单就只有`getConfigurations()`方法中的一行代码，就是返回了configurations，那么问题就集中到了configurations这个实例道理存了什么信息。

```java
protected static class AutoConfigurationEntry {
		private final List<String> configurations;
		private final Set<String> exclusions;
		private AutoConfigurationEntry() {
			this.configurations = Collections.emptyList();
			this.exclusions = Collections.emptySet();
		}
		/**
		 * Create an entry with the configurations that were contributed and their
		 * exclusions.
		 * @param configurations the configurations that should be imported
		 * @param exclusions the exclusions that were applied to the original list
		 */
		AutoConfigurationEntry(Collection<String> configurations, Collection<String> exclusions) {
			this.configurations = new ArrayList<>(configurations);
			this.exclusions = new HashSet<>(exclusions);
		}

		public List<String> getConfigurations() {
			return this.configurations;
		}

		public Set<String> getExclusions() {
			return this.exclusions;
		}

	}
```

configurations是一个List<String>,在AutoConfigurationEntry初始化接受传入的`Collection<String> configurations`，看看其初始化的地方**(见`selectImports`方法)**

```java
AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);
```

```java
protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    }
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
    configurations = removeDuplicates(configurations);
    Set<String> exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    configurations = filter(configurations, autoConfigurationMetadata);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    return new AutoConfigurationEntry(configurations, exclusions);
}
```

和**`configurations`**相关的部分

1. getCandidateConfigurations获取候选配置
2. removeDuplicates移除重复配置
3. removeAll清理掉排除在外的配置
4. filter获取所需

后三步是清洗工作，重要集中在第一步

```java
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());
    Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you " + "are using a custom packaging, make sure that file is correct.");
    return configurations;
}
```

> Load the fully qualified class names of factory implementations of the* given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given* class loader.

SpringFactoriesLoader.loadFactoryNames会使用给定类加载器从`FACTORIES_RESOURCE_LOCATION`获得所需的工厂实现的**类名**

```java
public static List<String> loadFactoryNames(Class<?> factoryClass, @Nullable ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    return  loadSpringFactories(classLoader).getOrDefault(factoryClassName,
                                                          Collections.emptyList());
}
```
这个东西在哪呢，点进去，看loadSpringFactories的加载
```java
private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {
	MultiValueMap<String, String> result = cache.get(classLoader);
	if (result != null) {
		return result;
	}

	try {
		Enumeration<URL> urls = (classLoader != null ?
				classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
				ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
		result = new LinkedMultiValueMap<>();
		while (urls.hasMoreElements()) {
			URL url = urls.nextElement();
			UrlResource resource = new UrlResource(url);
			Properties properties = PropertiesLoaderUtils.loadProperties(resource);
			for (Map.Entry<?, ?> entry : properties.entrySet()) {
				String factoryClassName = ((String) entry.getKey()).trim();
				for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {
					result.add(factoryClassName, factoryName.trim());
				}
			}
		}
		cache.put(classLoader, result);
		return result;
	}
	catch (IOException ex) {
		throw new IllegalArgumentException("Unable to load factories from location [" +
				FACTORIES_RESOURCE_LOCATION + "]", ex);
	}
}
```

终于看到了资源获取

1. classLoader从**指定位置**获取url
2. 将url转换成properties
3. 将properties转换成Map

而classLoader获取资源的文件就是它了

```
public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
```

传递过来的factoryClassName就是

```java
protected Class<?> getSpringFactoriesLoaderFactoryClass() {   
    return EnableAutoConfiguration.class;
}
```

在文件中找可找到EnableAutoConfiguration，见《附录EnableAutoConfiguration信息》。其配置的类名都是以AutoConfiguration结尾，这些自动配置类类似于以前的配置文件，会给IOC容器添加组件。

### 1.3 AutoConfiguration先IOC添加组件

以其中一个为例`HttpEncodingAutoConfiguration`

```java
@Configuration
@EnableConfigurationProperties(HttpProperties.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(CharacterEncodingFilter.class)
@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)
public class HttpEncodingAutoConfiguration {
```

1. `@Configuration`配置类的标识注解，说明本类的性质

2. `@EnableConfigurationProperties`表明开启`@ConfigurationProperties`，后一个注解在《03附录.重要注解》有解释：将配置文件中的值进行映射到bean中。

   ```java
   @ConfigurationProperties(prefix = "spring.http")
   public class HttpProperties {
       xx
       xx
   }
   ```

   很明显一定是在yaml或者properties中配置了一个前缀为spring.http的实例信息<font color="red">（暂时没有找到位置）</font>。

3. `@ConditionalOnWebApplication`是在某种条件下生效，这里表明是web应用就会加载

4. `@ConditionalOnClass`判断有没有CharacterEncodingFilter过滤器，解决乱码用的

5. `@ConditionalOnProperty`判断某个属性是否配置，这里表明要spring.http.encoding=enabled或者不配

6. 添加实现

   ```java
   private final HttpProperties.Encoding properties;
   
   public HttpEncodingAutoConfiguration(HttpProperties properties) {
       this.properties = properties.getEncoding();
   }
   
   @Bean
   @ConditionalOnMissingBean
   public CharacterEncodingFilter characterEncodingFilter() {
       CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
       filter.setEncoding(this.properties.getCharset().name());
       filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
       filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
       return filter;
   }
   ```

   这里使用`@Bean`添加了组件`properties`是`@EnableConfigurationProperties`导入的HttpProperties的一个实例，存储着`CharacterEncodingFilter`所需的编码信息。